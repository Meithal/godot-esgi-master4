+++
date = '2025-12-15T03:11:54+01:00'
title = 'Vibe'
+++

Avec départ binome et manque de temps pour tenir délais,
pris l'option de tester l'approche "vibe coding" pour s'en faire une opinion.
Vibe coding pour la visualisation du learning.

On s'est rendu compte que les poids générés sont beaucoup
trop disparates donc on a forcé la normalisation.

On a demandé a ce que les taches répétitives soient inscrites
dans un makefile car il echoue souvent a lancer
des commandes relatives et fallback sur des appels
absolus, gasillage de crédit.

Épuisé crédit gpt, claude et gemini sur une durée de 6 heures.

Il est parti sur codage en dur de couches cachées. On l'a forcé à
adopter une approche plus modulaire.

On lui a demandé une checklist de choses à faire si on veut
bricoler notre modèle.

On lui a demandé de rajouter les dépendances dans le makefile,
pour automatiser au mieux certains procédés.

Il a rajouté beaucoup de code inutile et spécifique à nos demandes,
on lui a demandé de nettoyer le code.

Verdict :

- écrit beaucoup de code très spécifique à la tache
qu'on lui demande, se contente d'ajouter couche de complexité
sur couche de complexité quand on lui demande un ajustement.
- a du mal a généraliser dès le début et réflechissant
à une approche modulaire et future proof sauf si
on lui demande très spécifiquement et très clairement.
- a énormément de mal à supprimer du code, ne fait qu'en rajouter
- on arrive vite a cours de liquidités pour le temps gratuit,
bonne chance pour réparer soi meme le gloubi goulba qu'il ne sort.

A utiliser pour des projets bénins, comme le visualisateur
de notre apprentissage, passer plus de temps en amont à lui
expliquer le style de code que l'on recherche, par défaut il
fait du code hyper spécialisé et rajoute couche sur couche
pour traiter les cas particuliers au lieu d'identifier
les généralisations.
